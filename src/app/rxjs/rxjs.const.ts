export const allData = {
  switchMap: {
    label: 'Switch Map',
    value: 'switchMap',
    definition1: `<h3><strong>Projects each source value to an Observable which is merged in the output Observable, emitting values only from the most recently projected Observable.</h2>`,
    definition2: `The main difference between switchMap and other flattening operators is the cancelling effect. On each emission the previous inner observable (the result of the function you supplied) is cancelled and the new observable is subscribed`,
    definition3: `you probably want to avoid switchMap in scenarios where every request needs to complete, think writes to a database. switchMap could cancel a request if the source emits quickly enough. In these scenarios <strong>mergeMap</strong> is the correct option.`,
  },
  concatMap: {
    label: 'Concat Map',
    value: 'concatMap',
    definition1: `<h3><strong>Projects each source value to an Observable which is merged in the output Observable, in a serialized fashion waiting for each one to complete before merging the next.</h2>`,
    definition2: `Map values to inner observable, subscribe and emit in order. ConcatMap keeps all the values unlike <strong>switchMap/exhaustMap</strong>`,
    definition3: `The difference between <strong>concatMap</strong> and <strong>mergeMap</strong> is the ordering. concatMap does not subscribe to the next observable until the previous completes. concatMap - Order by outer observable, mergeMap - Order by inner observable`,
  },
  mergeMap: {
    label: 'Merge Map',
    value: 'mergeMap',
    definition1: `<h3><strong>Projects each source value to an Observable which is merged in the output Observable.</strong></h2>`,
    definition2: `creates an Observable immediately for any source item, all previous Observables are kept alive. mergeMap allows for multiple inner subscriptions to be active at a time. Because of this, one of the most common use-case for mergeMap is requests that should not be canceled. Note that if order must be maintained <strong>concatMap</strong> is a better option`,
    definition3: `Be aware that because mergeMap maintains multiple active inner subscriptions at once it's possible to create a memory leak through long-lived inner subscriptions.`,
  },
  exhaustMap: {
    label: 'Exhaust Map',
    value: 'exhaustMap',
    definition1: `<h3><strong>Projects each source value to an Observable which is merged in the output Observable only if the previous projected Observable has completed.</strong></h2>`,
    definition2: `source items are ignored while the previous Observable is not completed.`,
    definition3: ` From the output, <strong>switchMap</strong> throttles any incomplete inner emits, but <strong>exhaustMap</strong> throttles following emits until the earlier ones complete.`,
  },
  combineLatest: {
    label: 'Combine Latest',
    value: 'combineLatest',
    definition1: `<h3><strong>When any observable emits a value, emit the last emitted value from each.</strong></h2>`,
    definition2: `This operator is best used when you have multiple, long-lived observables that rely on each other for some calculation or determination.`,
    definition3: `combineLatest will not emit an initial value until each observable emits at least one value.`,
  },
  merge: {
    label: 'Merge',
    value: 'merge',
    definition1: `<h3><strong>Creates an output Observable which concurrently emits all values from every given input Observable.</strong></h2>`,
    definition2: `The merge operator is your go-to solution when you have multiple observables that produce values independently and you want to combine their output into a single stream.`,
    definition3: `Keep in mind that merge will emit values as soon as any of the observables emit a value. This is different from <strong>combineLatest</strong>, which wait for each observable to emit at least one value before emitting a combined value.`,
  },
  concat: {
    label: 'Concat',
    value: 'concat',
    definition1: `<h3><strong>Creates an output Observable which sequentially emits all values from the first given Observable and then moves on to the next.</strong></h2>`,
    definition2: `The concat operator is best used when you need to combine multiple observables, but you want their emissions to be in a specific order, one after the other.`,
    definition3: `eep in mind that concat will only start emitting values from the next observable once the previous one has completed. This means that if one of your observables never completes, the subsequent observables will never emit any values.`,
  },
  forkJoin: {
    label: 'Fork Join',
    value: 'forkJoin',
    definition1: `<h3><strong>When all observables complete, emit the last emitted value from each.</strong></h2>`,
    definition2: `This operator is best used when you have a group of observables and only care about the final emitted value of each.`,
    definition3: `One common use case for this is if you wish to issue multiple requests on page load (or some other event) and only want to take action when a response has been received for all. In this way it is similar to how you might use <strong>Promise.all</strong>.`,
  },
  zip: {
    label: 'Zip',
    value: 'zip',
    definition1: `<h3><strong>Combines multiple Observables to create an Observable whose values are calculated from the values, in order, of each of its input Observables.</strong></h2>`,
    definition2: `This operator is ideal when you want to combine values from multiple observables in a pairwise fashion, like zipping together the teeth of a zipper.`,
    definition3: `Be mindful that zip will only emit a value when all input observables have emitted a corresponding value. This means if one observable has emitted more values than another, the unmatched values will be held back until the other observable emits its next value. In some cases, this could lead to unpaired values, making it important to ensure your observables are synchronized.`,
  },
  withLatestFrom: {
    label: 'With Latest From',
    value: 'withLatestFrom',
    definition1: `<h3><strong>Combines the source Observable with other Observables to create an Observable whose values are calculated from the latest values of each, only when the source emits.</strong></h2>`,
    definition2: `The withLatestFrom operator is useful when you have one main observable whose emissions depend on the latest values from one or more other observables. Think of it as a one-way data flow, where the primary observable takes the lead and other observables chime in with their most recent values. Keep in mind that withLatestFrom only emits a value when the main observable emits, and after each additional observable has emitted at least once`,
    definition3: `If you need to combine values from multiple observables that emit more than once and are interdependent, consider using <strong>combineLatest</strong> instead. And for scenarios where observables emit only once or you just need their last values, <strong>forkJoin</strong> might be a more suitable choice.`,
  },
  concatAll: {
    label: 'Concat All',
    value: 'concatAll',
    definition1: `<h3><strong>Converts a higher-order Observable into a first-order Observable by concatenating the inner Observables in order.</strong></h2>`,
    definition2: `The withLatestFrom operator is useful when you have one main observable whose emissions depend on the latest values from one or more other observables. Think of it as a one-way data flow, where the primary observable takes the lead and other observables chime in with their most recent values. Keep in mind that withLatestFrom only emits a value when the main observable emits, and after each additional observable has emitted at least once`,
    definition3: `If you need to combine values from multiple observables that emit more than once and are interdependent, consider using <strong>combineLatest</strong> instead. And for scenarios where observables emit only once or you just need their last values, <strong>forkJoin</strong> might be a more suitable choice.`,
  },
};
